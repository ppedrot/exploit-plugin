DECLARE PLUGIN "exploit_tactic"

let pp_constr fmt x = Pp.pp_with fmt (Printer.pr_constr x)

(** Given a term [fun (x1:t1) ... (xn:tn) => _] build a list of holes
    [?1:t1 ... ?n:tn] in the same order. Let-bindings are substituted. *)
let rec make_holes env sigma ty = match Term.kind_of_term ty with
| Term.Lambda (_, arg, ty) ->
  let (sigma, hole) = Evarutil.new_evar env sigma arg in
  let ty = Vars.subst1 hole ty in
  let (sigma, holes) = make_holes env sigma ty in
  (sigma, hole :: holes)
| Term.LetIn (_, body, _, ty) ->
  let ty = Vars.subst1 body ty in
  make_holes env sigma ty
| _ -> sigma, []

let exploit (c : Term.constr) =
  Proofview.Goal.nf_enter begin fun gl ->
  (* the type of [c] is [ty] *)
  let ty = Tacmach.New.pf_type_of gl c in

  (* ty can be written as [forall (x1:t1) ... (xn:tn), t] 
     here, [ctx] is [(xn, tn); ...; (x1,t1))] *)
  let ctx, t = Term.decompose_prod_assum ty in 

  (* the type of the conclusion of the goal is [concl] *)
  let concl = Proofview.Goal.concl gl in
  
  (* We want to build the proof term pf
     
     [fun (x1:t1) ... (xn:tn) (m: t -> concl) => m (c x1 .... xn)]
     
     We start to build the body of the proof term [pf_body] *)
  let pf_body = Term.mkApp (Term.mkRel 1, [| Term.mkApp (c, Termops.extended_rel_vect 1 ctx) |]) in

  (* We now need to extend the context to accomodate for the extra
     parameter [m] of type [t -> concl]. 
     
     Note here that the type [t] may depend on the context
     [ctx]. There is no need to lift [t], because it is used in the
     exact same context as before; and there should not be de Bruijn
     indices in [concl].  *)
  
  let ctx = (Names.Anonymous,None, Term.mkArrow t concl ) :: ctx in 
  let pf_term = Term.it_mkLambda_or_LetIn pf_body ctx in

  (* Sanity check: we pretty print the term that we are going to apply*)
  let _ = Format.printf "Proof term produced by the exploit tactic:\n%a\n" pp_constr pf_term in 
  
  Proofview.Refine.refine_casted begin fun sigma ->
    let sigma, holes = make_holes (Proofview.Goal.env gl) sigma pf_term in
    sigma, Term.mkApp (pf_term, Array.of_list holes)
  end

  end
    
    
TACTIC EXTEND exploit
  | ["exploit" constr(c)] ->     [exploit c]
END;;


(* Looking carefully at the things we had to do to make the above
   tactics work, we imagine that we should be able to use the following
   tactic instead. 
   
   However, it fails with the following error message.

   Error: Application of lemmas whose beta-iota normal form contains
   metavariables deep inside the term is not supported; try "refine" instead.


let exploit2 c = fun gl -> 
  let ty = Tacmach.pf_type_of gl c in 
  let ctx, t = Term.decompose_prod_assum ty in 
  let concl = Tacmach.pf_concl gl in 
  let mvars = (List.map (fun _ -> Evarutil.mk_new_meta ()) ctx) in 
  let pf_body = Term.mkApp (Term.mkRel 1, [| Term.applist (c, mvars) |]) in 
  let term = Term.mkProd (Names.Anonymous, Term.mkArrow t concl, pf_body) in 
  Tactics.refine (Term.mkApp (term, [|Evarutil.mk_new_meta ()|])) gl
*)
